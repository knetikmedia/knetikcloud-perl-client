=begin comment

Knetik Platform API Documentation latest 

This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com

OpenAPI spec version: latest 
Contact: support@knetik.com
Generated by: https://github.com/swagger-api/swagger-codegen.git

=end comment

=cut

#
# NOTE: This class is auto generated by the swagger code generator program. 
# Do not edit the class manually.
# Ref: https://github.com/swagger-api/swagger-codegen
#
package WWW::SwaggerClient::Object::Sku;

require 5.6.0;
use strict;
use warnings;
use utf8;
use JSON qw(decode_json);
use Data::Dumper;
use Module::Runtime qw(use_module);
use Log::Any qw($log);
use Date::Parse;
use DateTime;

use base ("Class::Accessor", "Class::Data::Inheritable");


#
#
#
# NOTE: This class is auto generated by the swagger code generator program. Do not edit the class manually.
# REF: https://github.com/swagger-api/swagger-codegen
#

=begin comment

Knetik Platform API Documentation latest 

This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com

OpenAPI spec version: latest 
Contact: support@knetik.com
Generated by: https://github.com/swagger-api/swagger-codegen.git

=end comment

=cut

#
# NOTE: This class is auto generated by the swagger code generator program. 
# Do not edit the class manually.
# Ref: https://github.com/swagger-api/swagger-codegen
#
__PACKAGE__->mk_classdata('attribute_map' => {});
__PACKAGE__->mk_classdata('swagger_types' => {});
__PACKAGE__->mk_classdata('method_documentation' => {}); 
__PACKAGE__->mk_classdata('class_documentation' => {});

# new object
sub new { 
    my ($class, %args) = @_; 

	my $self = bless {}, $class;
	
	foreach my $attribute (keys %{$class->attribute_map}) {
		my $args_key = $class->attribute_map->{$attribute};
		$self->$attribute( $args{ $args_key } );
	}
	
	return $self;
}  

# return perl hash
sub to_hash {
    return decode_json(JSON->new->convert_blessed->encode( shift ));
}

# used by JSON for serialization
sub TO_JSON { 
    my $self = shift;
    my $_data = {};
    foreach my $_key (keys %{$self->attribute_map}) {
        if (defined $self->{$_key}) {
            $_data->{$self->attribute_map->{$_key}} = $self->{$_key};
        }
    }
    return $_data;
}

# from Perl hashref
sub from_hash {
    my ($self, $hash) = @_;

    # loop through attributes and use swagger_types to deserialize the data
    while ( my ($_key, $_type) = each %{$self->swagger_types} ) {
    	my $_json_attribute = $self->attribute_map->{$_key}; 
        if ($_type =~ /^array\[/i) { # array
            my $_subclass = substr($_type, 6, -1);
            my @_array = ();
            foreach my $_element (@{$hash->{$_json_attribute}}) {
                push @_array, $self->_deserialize($_subclass, $_element);
            }
            $self->{$_key} = \@_array;
        } elsif (exists $hash->{$_json_attribute}) { #hash(model), primitive, datetime
            $self->{$_key} = $self->_deserialize($_type, $hash->{$_json_attribute});
        } else {
        	$log->debugf("Warning: %s (%s) does not exist in input hash\n", $_key, $_json_attribute);
        }
    }
  
    return $self;
}

# deserialize non-array data
sub _deserialize {
    my ($self, $type, $data) = @_;
    $log->debugf("deserializing %s with %s",Dumper($data), $type);
        
    if ($type eq 'DateTime') {
        return DateTime->from_epoch(epoch => str2time($data));
    } elsif ( grep( /^$type$/, ('int', 'double', 'string', 'boolean'))) {
        return $data;
    } else { # hash(model)
        my $_instance = eval "WWW::SwaggerClient::Object::$type->new()";
        return $_instance->from_hash($data);
    }
}



__PACKAGE__->class_documentation({description => '',
                                  class => 'Sku',
                                  required => [], # TODO
}                                 );

__PACKAGE__->method_documentation({
    'additional_properties' => {
    	datatype => 'HASH[string,Property]',
    	base_name => 'additional_properties',
    	description => 'A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template',
    	format => '',
    	read_only => '',
    		},
    'currency_code' => {
    	datatype => 'string',
    	base_name => 'currency_code',
    	description => 'The currency code for the SKU, a three letter string (ISO3)',
    	format => '',
    	read_only => '',
    		},
    'description' => {
    	datatype => 'string',
    	base_name => 'description',
    	description => 'The description of the SKU (Ex: An item comes in multiple sizes/colors, each needing its own unique description)',
    	format => '',
    	read_only => '',
    		},
    'inventory' => {
    	datatype => 'int',
    	base_name => 'inventory',
    	description => 'The number of SKUs currently in stock',
    	format => '',
    	read_only => '',
    		},
    'min_inventory_threshold' => {
    	datatype => 'int',
    	base_name => 'min_inventory_threshold',
    	description => 'Alerts vendor when SKU inventory drops below this value',
    	format => '',
    	read_only => '',
    		},
    'original_price' => {
    	datatype => 'double',
    	base_name => 'original_price',
    	description => 'The base price before any sale',
    	format => '',
    	read_only => '',
    		},
    'price' => {
    	datatype => 'double',
    	base_name => 'price',
    	description => 'The current price of the SKU with sales, if any. Set original_price for the base',
    	format => '',
    	read_only => '',
    		},
    'published' => {
    	datatype => 'boolean',
    	base_name => 'published',
    	description => 'Whether or not the SKU is currently published',
    	format => '',
    	read_only => '',
    		},
    'sale_id' => {
    	datatype => 'int',
    	base_name => 'sale_id',
    	description => 'The id of a sale affecting the price, if any',
    	format => '',
    	read_only => '',
    		},
    'sale_name' => {
    	datatype => 'string',
    	base_name => 'sale_name',
    	description => 'The name of a sale affecting the price, if any',
    	format => '',
    	read_only => '',
    		},
    'sku' => {
    	datatype => 'string',
    	base_name => 'sku',
    	description => 'The stock keeping unit (SKU), a unique identifier for a given product.  Max 40 characters',
    	format => '',
    	read_only => '',
    		},
    'start_date' => {
    	datatype => 'int',
    	base_name => 'start_date',
    	description => 'The date the sku becomes available, unix timestamp in seconds.  If set to null, sku will become available immediately',
    	format => '',
    	read_only => '',
    		},
    'stop_date' => {
    	datatype => 'int',
    	base_name => 'stop_date',
    	description => 'The date the sku becomes unavailable, unix timestamp in seconds.  If set to null, sku is always available',
    	format => '',
    	read_only => '',
    		},
});

__PACKAGE__->swagger_types( {
    'additional_properties' => 'HASH[string,Property]',
    'currency_code' => 'string',
    'description' => 'string',
    'inventory' => 'int',
    'min_inventory_threshold' => 'int',
    'original_price' => 'double',
    'price' => 'double',
    'published' => 'boolean',
    'sale_id' => 'int',
    'sale_name' => 'string',
    'sku' => 'string',
    'start_date' => 'int',
    'stop_date' => 'int'
} );

__PACKAGE__->attribute_map( {
    'additional_properties' => 'additional_properties',
    'currency_code' => 'currency_code',
    'description' => 'description',
    'inventory' => 'inventory',
    'min_inventory_threshold' => 'min_inventory_threshold',
    'original_price' => 'original_price',
    'price' => 'price',
    'published' => 'published',
    'sale_id' => 'sale_id',
    'sale_name' => 'sale_name',
    'sku' => 'sku',
    'start_date' => 'start_date',
    'stop_date' => 'stop_date'
} );

__PACKAGE__->mk_accessors(keys %{__PACKAGE__->attribute_map});


1;
